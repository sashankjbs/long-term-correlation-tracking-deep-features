function runTracker(file_path)
% file_path should contain the path to the folder with the .jpg files

files = dir(strcat(file_path, '*.jpg'));
num_files = length(files);

<<<<<<< Updated upstream
lambda = 0.01;
=======
lambda = 1e-4;
>>>>>>> Stashed changes
learning_rate = 0.01;
global kernel_width;
kernel_width = 1;
visualize = 1;
cell_size = 4;
label_sigma = 0.1;
<<<<<<< Updated upstream
=======
global A_scale;
A_scale = 1.02;

global lambda_s;
lambda_s = 0.01;

motion_threshold = 0.15;
appearance_threshold = 0.38;


N = 33;

scale_sigma = sqrt(N)/4;
ss = (1:N) - ceil(N/2);
ys = exp(-0.5 * (ss.^2) / scale_sigma^2);
ysf = single(fft(ys));

if mod(N,2) == 0
    scale_window = single(hann(N+1));
    scale_window = scale_window(2:end);
else
    scale_window = single(hann(N));
end


>>>>>>> Stashed changes

for i = 1:num_files
    % Read the next image
    current_image_name = files(i).name;
    current_image_path = strcat(file_path, current_image_name);
    img = imread(current_image_path);
    img = rgb2gray(img);
    
    % If it is the first image, then prompt user to select the object to be
    % tracked
    
    if(i == 1)
        imshow(img);
<<<<<<< Updated upstream
        %rect = getrect;
        rect = [254, 215, 81, 34];
        rect = floor(rect);
        close;
        
        % pos has [x, y] values. patch_size has width and height.
        pos = rect(1:2);
        target_size = rect(3:4);
        motion_model_patch_size = target_size .* [1.4, 2.8];
        app_model_patch_size = target_size + 8;
        
        patch = getPatch(img, pos, patch_size);
        
        motion_model_output_size = [
        size_y = floor(size(patch, 1)/cell_size);
        size_x = floor(size(patch, 2)/cell_size);
        
        label_sigma = sqrt(size_x * size_y) * label_sigma / 2;
=======
        rect = [254 215 81 34];
%        rect = getrect;
        close;
        
%         temp = rect(1:2) + rect(3:4)/2;
%         rect(1) = temp(2);
%         rect(2) = temp(1);
%         tempp = rect(3);
%         rect(3) = rect(4);
%         rect(4) = tempp;
       
        
        pos = rect(1:2);
        t_size = rect(3:4);
        intial_selected_size = t_size;
        app_model_size = t_size + 8;
        if t_size(1) > t_size(2)
            t_size(1) = 1.4*t_size(1);
            t_size(2) = 2.8*t_size(2);
        end
        motion_model_size = floor(t_size);
        
        target_disp = rect(3:4);
        
        patch = getPatch(img, pos, motion_model_size);
        
        
        label_sigma = sqrt(prod(intial_selected_size)) * label_sigma/cell_size;
        
        size_x = floor(motion_model_size(2)/cell_size);
        size_y = floor(motion_model_size(1)/cell_size);
        
        % Rc
>>>>>>> Stashed changes
        yf = fft2(getLabelImage(size_x, size_y, label_sigma));
        
        cos_window = hann(size_y) * hann(size_x)';
        
        xf = fft2(computeFeatures(patch, cell_size, cos_window));
        xkf = computeGaussianCorrelation(xf, xf, kernel_width);
        
        % Equation 2
        A = yf./(xkf + lambda);
<<<<<<< Updated upstream
    else
        % Equation 3
        patch = getPatch(img, pos, patch_size);
        
        zf = fft2(computeFeatures(patch, cell_size, cos_window));
        diff = getNewPos(zf, xf, A)
        %pos = pos + cell_size * [diff(2) diff(1)];
        pos = pos + cell_size * [diff(2) - floor(size_x/2)-1, diff(1) - floor(size_y/2)-1];
        
        if(visualize == 1)
            imshow(img); hold on;
            rectangle('Position', [pos, patch_size], 'EdgeColor', 'r');
            drawnow;
        end
        
        zkf = computeGaussianCorrelation(zf, zf, kernel_width);
        
        A_z = yf./(zkf + lambda);
        
        % Equation 4
        x = (1 - learning_rate) * xf + learning_rate * zf;
        A = (1 - learning_rate) * A + learning_rate * A_z;
        
=======
        
        
            
        %Rt
        size_y_t = floor(app_model_size(1)/cell_size);
        size_x_t = floor(app_model_size(2)/cell_size);
        
        yf_t = fft2(getLabelImage(size_x_t, size_y_t, label_sigma));
        
   %     cos_window_t = ones(size_y_t,size_x_t);
        
        patch = getPatch(img, pos, app_model_size);
        xf_t = fft2(computeFeatures(patch, cell_size, []));
        xkf_t = computeGaussianCorrelation(xf_t, xf_t, kernel_width);
        
        % Equation 2
        A_t = yf_t./(xkf_t + lambda);
        
        %current_scale
        current_scale = 1;
        [scale_pyr,~] = scalePyramid(app_model_size,N,img,pos,cell_size,scale_window,current_scale);
        
        sf = fft(scale_pyr,[],2);
        s_num = bsxfun(@times, ysf, conj(sf));
        s_den = sum(sf .* conj(sf), 1);
        
        
        
    else
        % Equation 3
        patch = getPatch(img, pos, motion_model_size);
        
        zf = fft2(computeFeatures(patch, cell_size, cos_window));
        [diff,~] = getNewPos(zf, xf, A);
        pos = pos + cell_size * [diff(1) - floor(size(zf,1)/2)-1, diff(2) - floor(size(zf,2)/2)-1];
        
        patch = getPatch(img, pos, app_model_size);
        zf_t = fft2(computeFeatures(patch, cell_size, []));
        [~,max_response] = getNewPos(zf_t, xf_t, A_t);
        
        %target
        patch = getPatch(img, pos, app_model_size);
        zf_t = fft2(computeFeatures(patch, cell_size,[]));
        [scale_pyr,scale] = scalePyramid(app_model_size,N,img,pos,cell_size,scale_window,current_scale);
        [s,sf] = getOptimalScale(scale_pyr,scale,s_num,s_den);
        
        current_scale = current_scale*s;
        if current_scale > 5.2773
            current_scale = 5.2773;
        elseif current_scale<0.0534
            current_scale = 0.0534;
        end
        
        
        
        ns_num = bsxfun(@times, ysf, conj(sf));
        ns_den = sum(sf .* conj(sf), 1);


        target_disp = ceil(target_disp*current_scale);
       
        
        if(visualize == 1)
            imshow(img); hold on;
            rectangle('Position', [pos([2,1]) - target_disp([2,1])/2, target_disp([2,1])], 'EdgeColor', 'r');
            drawnow;
            %pause(0.5);
        end
        
        zkf = computeGaussianCorrelation(zf, zf, kernel_width);
        A_z = yf./(zkf + lambda);
        
         % target
        xkf_t = computeGaussianCorrelation(zf_t, zf_t, kernel_width);
        A_n_t = yf_t./(xkf_t + lambda);
  
        
        % Equation 4
        xf = (1 - learning_rate) * xf + learning_rate * zf;
        A = (1 - learning_rate) * A + learning_rate * A_z;
        
         s_den = (1 - learning_rate) * s_den + learning_rate * ns_den;
        s_num = (1 - learning_rate) * s_num + learning_rate * ns_num;
        
        
        if(max_response > appearance_threshold)
            xf_t = (1 - learning_rate) * xf_t + learning_rate * zf_t;
            A_t = (1 - learning_rate) * A_t + learning_rate * A_n_t;    
        end
        

        
>>>>>>> Stashed changes
    end

end